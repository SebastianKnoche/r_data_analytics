---
title: "String Manipulation Challenge"
author: "Sebastian Knoche"
date: "2021-05-04"
output:
  html_document:
    keep_md: yes
  pdf_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Reverse Strings

Write a function that reverses the order of the words of the input sentence.
```{r echo=FALSE}
# generate the sample string
my.sentence <- "here is long sentence, potentially generated by reading from some text-file"

my.wordSeqReverse <- function(any_string, any_split=" ", return_as_list=FALSE) {
  rev_word_seq <- paste0(
      rev(
        unlist(
          strsplit(
            any_string,
            split = any_split
            )
          )
        ),
      collapse = any_split
    )
  return(rev_word_seq)
}
```

```{r}
my.sentence
my.wordSeqReverse(my.sentence)
```

Now we want a function that keeps the order of the sentence, but
reverses the words!
```{r echo=FALSE}
my.strReverse <- function(any_string) {
  # split it into words
  tmp_words <- unlist(
    strsplit(
      any_string, split = " "
      )
    )
  # iterate over words
  for(i in seq_along(tmp_words)) {
    # replace each one with reversed order word
    tmp_words[i] <- my.wordSeqReverse(
      any_string = tmp_words[i],
      any_split = ""
      )
    }
  # recreate sentence with reversed words
  return(
    paste0(
      tmp_words,
      collapse = " "
      )
    )
}
```

```{r}
my.sentence
my.strReverse(my.sentence)
```

***

## 1 Remove Vowel

According to a linguistic theory, texts are still readable when the vowels are missing.

### 1.1 First Task:

Consider the following function `is.vowel(char)` which returns `TRUE` if the character is a vowel. Vowels are defined as `a`, `e`, `i`, `o` and `u`.

```{r}
is.vowel <- function(char) {
  if(char == "a" || char == "e" || char == "i" || char == "o" || char == "u")
    return(TRUE)
  return(FALSE)
}
```

Testing the function:
```{r}
is.vowel("e")
```

```{r}
is.vowel("f")
```

Tasks:

• Explain how the function works

> The Function checks if the given `char` is either one of the vowels defined and returns `TURE` or `FALSE` respectively. (It compares the value of `char` with each value for the vowels)

• What happens if we enter the following (and why):

```{r}
is.vowel(c("e","g"))
```

> `is.fowel()` checks if the first argument has the value associated with one of the vowels. `"e"` meets the criterium of `char == "e"`, so `TRUE` is returned. Either way, the first comparison leads to an execution of `return()` and therefore exits the function. All other values after the first one are ignored.


### 1.2 Extension

Now write a function `remove.vowels(string)` that removes all vowels in the sentence. Are the linguists right?

```{r echo=FALSE}
remove.vowels <- function(string) {
  # split it into words
  tmp_words <- unlist(
    strsplit(
      string, split = " "
      )
    )
  # iterate over words
  for(i in seq_along(tmp_words)) {
    tmp_word <- unlist(
      strsplit(
        tmp_words[i],
        split = ""
        )
      )
    # iterate over letters
    for(j in seq_along(tmp_word)) {
      # assign letter to the new word, but only if it is no vowel
      tmp_word[j] <- ifelse(is.vowel(tmp_word[j]), "", tmp_word[j])
    }
    # recreate word without vowels
    tmp_words[i] <- paste0(
      tmp_word,
      collapse = ""
    )
    }
  # recreate sentence without vowels
  return(
    paste0(
      tmp_words,
      collapse = " "
      )
    )
}
```

```{r echo=FALSE}
# # alternative code by Mick Molitor
# remove.vowel <- function(string) {
#   x <- string
#   erga = gsub("a","", x)
#   ergi = gsub("i","", erga)
#   erge = gsub("e","", ergi)
#   ergu = gsub("u","", erge)
#   ergo = gsub("o","", ergu)
#   return(ergo)
#   }

# code by Salmai Qari
# gsub("a|i", "", x)

# new attempt on the function, inspired by these influences
remove.vowels2 <- function(string) {
  return(
    gsub(
      "a|e|i|o|u",
      "",
      string
      )
    )
  }
```


Testing the function (using strwrap is not necessary, but it improves ease of reading for pdf-files): We first enter a string:

```{r}
text.1 <- "Tours of the campus were very popular. Student guides showed more than 100 curious guests around the campus, answering a range of questions on the way."
strwrap(text.1)
```

Now we apply the function to the string:

```{r}
strwrap(remove.vowels(text.1) )
strwrap(remove.vowels2(text.1) )
```

### 1.3 Sets

The function `is.element(el, set)` works on vectors and returns `TRUE` for each `el` in `set`. Example:

```{r echo=FALSE}
is.element <- function(el, set) {
  tmp_res <- el
  for(i in seq_along(el)) {
    for(j in seq_along(set)) {
      if((!is.na(tmp_res[i]))&(tmp_res[i]!=TRUE)) {
        tmp_res[i] <- el[i] == set[j]
        }
      }
    }
    return(as.logical(tmp_res))
  }
```

```{r}
is.element(el=c("a","b","c"),set=c("i","a"))
```

Write down (on paper) a function `is.vowel.vect` that accepts a vector of characters as an input.

```{r echo=FALSE}
is.vowel.vect <- function(vowel.vect) {
  tmp_res <- c()
  for(i in seq_along(vowel.vect)) {
    tmp_res[i] <- is.vowel(vowel.vect[i])
  }
  return(tmp_res)
}
```

Testing

```{r}
is.vowel.vect(c("a","b","c","i"))
```

## 2 Interchange Letters

According to a second theory, it is still possible to read a text, if only the first and the last letter are on the right position and the rest is randomly interchanged.

### 2.1 Step 1

Write a function that randomly interchanges all the letters of a word.

```{r echo=FALSE}
# library(stringi)
# 
# stri_rand_shuffle(c("of"))
```

```{r echo=FALSE}
interchange.word <- function(string) {
  # split it into words
  tmp_words <- unlist(
    strsplit(
      string, split = " "
      )
    )
  # iterate over words
  for(i in seq_along(tmp_words)) {
    tmp_word <- unlist(
      strsplit(
        tmp_words[i],
        split = ""
        )
      )
    # randomise the order of the letters
    tmp_rnd = sample(1:nchar(tmp_words[i]))
    tmp_word_rnd <- tmp_word

    # iterate over letters
    for(j in seq_along(tmp_word)) {
      # assign letter to the new word, but only if it is no vowel
      tmp_word_rnd[j] <- tmp_word[tmp_rnd[j]]
    }
    # create randomised word
    tmp_words[i] <- paste0(
      tmp_word_rnd,
      collapse = ""
    )
    }
  # recreate sentence with randomised words
  return(
    paste0(
      tmp_words,
      collapse = " "
      )
    )
}
```

Testing the function:

```{r}
interchange.word("of")
```

```{r}
interchange.word("Testfunction")
```

```{r}
interchange.word("Testfunction")
```

### 2.2 Step 2

Now write a function that exchanges only the characters of the middle of the word (between first and last character) Use your function from step 1. The function should not change anything, if the word is composed of less than 4 characters.

The function has an argument called exclude which is vector of potential punctuation marks at the end of a word. You can assume that there is only one possible punctuation mark. If there is such a mark, it should not be changed and not counted towards the number of characters the actual word is composed of.
Hence, Tes. is a three-character word and therefore nothing will be changed. Use the following vector of punctuation marks: exclude=c(",",".","!","?").

In summary, the function header should look like this:

```{r eval=FALSE}
interchange.middle.of.word <- function(string, exclude=c(",",".","!","?"))
```

```{r echo=FALSE}
# # Mick Molitor
# interchange.middle.of.word <- function(string, exclude=c(",",".","!","?")){ if (nchar(string) <= 4) return(string) else i=sample(2:(nchar(string)-1)) sepletters <- unlist(strsplit(string, "")) x <- nchar(string) paste(c(sepletters[1],sepletters[i],sepletters[x]), collapse="") }
# 
# # if ( len.char < 4) return(string)  # Salmai Qari
# # letzter <- sepletters[length(sepletters)]  # Salmai Qari
```

```{r echo=FALSE}
# # Yilun
# ExcludeRegEx = paste(c("[",exclude,"]","$"),collapse = "")
# CharOnly = gsub(ExcludeRegEx,"",string)) 
```


Testing the function:

```{r}
#interchange.middle.of.word("Tes")
```
## [1] "Tes"

```{r}
#interchange.middle.of.word("Tes")
```
## [1] "Tes"

```{r}
#interchange.middle.of.word("Hm?")
```
## [1] "Hm?"

```{r}
#interchange.middle.of.word("Hm!")
```
## [1] "Hm!"

```{r}
#interchange.middle.of.word("well!")
```
## [1] "wlel!"

```{r}
#interchange.middle.of.word("well!")
```
## [1] "wlel!"

```{r}
#interchange.middle.of.word("well!")
```
## [1] "well!"

```{r}
#interchange.middle.of.word("hello?")
```
## [1] "hlleo?"

```{r}
#interchange.middle.of.word("Testfunction!")
```
## [1] "Teuifcsotntn!"

```{r}
#interchange.middle.of.word("Testfunction?")
```
## [1] "Tuostctfnein?"

```{r}
#interchange.middle.of.word("Testfunction,")
```
## [1] "Tttnosecifun,"