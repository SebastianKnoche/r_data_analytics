---
title: "String Manipulation Challenge"
author: "Sebastian Knoche"
date: "`r format(file.info(knitr::current_input())$atime, '%Y-%m-%d')`"
output:
  html_document:
    keep_md: yes
  pdf_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Reverse Strings

Write a function that reverses the order of the words of the input sentence.
```{r echo=FALSE}
# generate the sample string
my.sentence <- "here is long sentence, potentially generated by reading from some text-file"

my.wordSeqReverse <- function(any_string, any_split=" ", return_as_list=FALSE) {
  rev_word_seq <- paste0(
      rev(
        unlist(
          strsplit(
            any_string,
            split = any_split
            )
          )
        ),
      collapse = any_split
    )
  return(rev_word_seq)
}
```

```{r}
my.sentence
my.wordSeqReverse(my.sentence)
```

Now we want a function that keeps the order of the sentence, but
reverses the words!
```{r echo=FALSE}
my.strReverse <- function(any_string) {
  # update: changed the replacement part from for loop to lapply
  # the old version can be found in the comments below the function
  
  # split it into words
  tmp_words <- strsplit(
    any_string, split = " "
    )
  # replace each one with reversed order word
  tmp_words <- unlist(
    lapply(
      tmp_words[[1]], my.wordSeqReverse, any_split = ""
      )
    )
  # recreate sentence with reversed words
  return(
    paste0(
      tmp_words,
      collapse = " "
      )
    )
}

##### WITHOUT lapply
#   # split it into words
#   tmp_words <- unlist(
#     strsplit(
#       any_string, split = " "
#       )
#     )
#   # iterate over words
#   for(i in seq_along(tmp_words)) {
#     # replace each one with reversed order word
#     tmp_words[i] <- my.wordSeqReverse(
#       any_string = tmp_words[i],
#       any_split = ""
#       )
#     }
```

```{r}
my.sentence
my.strReverse(my.sentence)
```

***

## 1 Remove Vowel

According to a linguistic theory, texts are still readable when the vowels are missing.

### 1.1 First Task:

Consider the following function `is.vowel(char)` which returns `TRUE` if the character is a vowel. Vowels are defined as `a`, `e`, `i`, `o` and `u`.

```{r}
is.vowel <- function(char) {
  if(char == "a" || char == "e" || char == "i" || char == "o" || char == "u")
    return(TRUE)
  return(FALSE)
}
```

Testing the function:
```{r}
is.vowel("e")
```

```{r}
is.vowel("f")
```

Tasks:

• Explain how the function works

> The Function checks if the given `char` is either one of the vowels defined and returns `TURE` or `FALSE` respectively. (It compares the value of `char` with each value for the vowels)

• What happens if we enter the following (and why):

```{r}
is.vowel(c("e","g"))
```

> `is.fowel()` checks if the first argument has a value associated with one of the vowels defined. `"e"` meets the criterium of `char == "e"`, so `TRUE` is returned. Either way, the first comparison leads to an execution of `return()` and therefore exits the function. All other values after the first one are ignored.


### 1.2 Extension

Now write a function `remove.vowels(string)` that removes all vowels in the sentence. Are the linguists right?

```{r echo=FALSE}
remove.vowels <- function(string) {
  # update: revised remove.vowels() after class, changed for loop into gsub
  # the old version can be found in the comments below the function

    return(
    gsub(
      "a|e|i|o|u",
      "",
      string
      )
    )
}

##### WITHOUT gsub
#   # split it into words
#   tmp_words <- unlist(
#     strsplit(
#       string, split = " "
#       )
#     )
#   # iterate over words
#   for(i in seq_along(tmp_words)) {
#     tmp_word <- unlist(
#       strsplit(
#         tmp_words[i],
#         split = ""
#         )
#       )
#     # iterate over letters
#     for(j in seq_along(tmp_word)) {
#       # assign letter to the new word, but only if it is no vowel
#       tmp_word[j] <- ifelse(is.vowel(tmp_word[j]), "", tmp_word[j])
#     }
#     # recreate word without vowels
#     tmp_words[i] <- paste0(
#       tmp_word,
#       collapse = ""
#     )
#     }
#   # recreate sentence without vowels
#   return(
#     paste0(
#       tmp_words,
#       collapse = " "
#       )
#     )
```

Testing the function (using strwrap is not necessary, but it improves ease of reading for pdf-files): We first enter a string:

```{r}
text.1 <- "Tours of the campus were very popular. Student guides showed more than 100 curious guests around the campus, answering a range of questions on the way."
strwrap(text.1)
```

Now we apply the function to the string:

```{r}
strwrap(remove.vowels(text.1) )
```

### 1.3 Sets

The function `is.element(el, set)` works on vectors and returns `TRUE` for each `el` in `set`. Example:

```{r echo=FALSE}
is.element <- function(el, set) {
  # update: the old version did overwrite the bolean value each time
  # the unintended result was the comparison of each element of el with
  # the last element of set. It seemed to work for the given example values
  # and was discovered later. It was corrected now so that other input i.e.
  # > is.element(el=c("a","i","c"),set=c("i","a"))
  # now gives the intended result
  # [1]  TRUE  TRUE FALSE

  tmp_res <- el
  for(i in seq_along(el)) {
    for(j in seq_along(set)) {
      if((!is.na(tmp_res[i]))&(tmp_res[i]!=TRUE)) {
        tmp_res[i] <- el[i] == set[j]
        }
      }
    }
    return(as.logical(tmp_res))
  }
```

```{r}
is.element(el=c("a","b","c"),set=c("i","a"))
```

Write down (on paper) a function `is.vowel.vect` that accepts a vector of characters as an input.

```{r echo=FALSE}
is.vowel.vect <- function(vowel.vect) {
  tmp_res <- sapply(
      vowel.vect, is.vowel
    )
  return(tmp_res)
}

### WITHOUT sapply
#   tmp_res <- c()
#   for(i in seq_along(vowel.vect)) {
#     tmp_res[i] <- is.vowel(vowel.vect[i])
#   }
#   return(tmp_res)
```

Testing

```{r}
is.vowel.vect(c("a","b","c","i"))
```

## 2 Interchange Letters

According to a second theory, it is still possible to read a text, if only the first and the last letter are on the right position and the rest is randomly interchanged.

### 2.1 Step 1

Write a function that randomly interchanges all the letters of a word.

```{r echo=FALSE}
### lazy solution...
# library(stringi)
# interchange.word <- function(string) {
#   return(stri_rand_shuffle(c(string)))
# }

interchange.word <- function(string) {
  tmp_len <- nchar(string)
  # split word into letters
  tmp_str <- unlist(
    strsplit(
      string,
      split = ""
    )
  )
  # randomise the order of the word`s letters
  tmp_rnd <- sample(1:tmp_len)

  # recreate the word with a randomised order of letters
  return(
    paste0(
      tmp_str[tmp_rnd],
      collapse = ""
    )
  )
}
```

Testing the function:

```{r}
interchange.word("of")
```

```{r}
interchange.word("Testfunction")
```

```{r}
interchange.word("Testfunction")
```

### 2.2 Step 2

Now write a function that exchanges only the characters of the middle of the word (between first and last character) Use your function from step 1. The function should not change anything, if the word is composed of less than 4 characters.

The function has an argument called exclude which is vector of potential punctuation marks at the end of a word. You can assume that there is only one possible punctuation mark. If there is such a mark, it should not be changed and not counted towards the number of characters the actual word is composed of.
Hence, Tes. is a three-character word and therefore nothing will be changed. Use the following vector of punctuation marks: exclude=c(",",".","!","?").

In summary, the function header should look like this:

```{r echo=FALSE}
interchange.middle.of.word <- function(string, exclude=c(",",".","!","?")){
  # generate a RegEx for the contents of the exclude vector
  ExcludeRegEx <- paste(c("[", exclude, "]", "$"), collapse = "")
  # delete the punctuation mark at the end of the string
  tmp_wrd <- gsub(ExcludeRegEx, "", string)
  # length of the word (excluding punctuation)
  tmp_len <- ifelse(
    nchar(tmp_wrd) < nchar(string),
    nchar(tmp_wrd), nchar(string))
  if(tmp_len < 4){
    # do not randomise if the word consists of less than four letters
    return(string)
  } else {
    # split word into letters
    tmp_str <- unlist(
      strsplit(
        string,
        split = ""
      )
    )
    # randomise the order of the word`s middle letters (second to penultimate)
    tmp_rnd <- sample(2:(tmp_len-1))
    # recreate the word with a randomised order of the middle letters
    # and add back the punctuation if there was any
    tmp_vec <- c(
      tmp_str[1],        # first letter of the word
      tmp_str[tmp_rnd],  # randomised middle letters
      tmp_str[tmp_len],  # last letter of the word
      ifelse(
        is.na(tmp_str[tmp_len+1]), # was there any punctuation in string?
        "",              # no punctuation added
        tmp_str[tmp_len+1]) # punctuation added
    )
    return(
      paste0(
        tmp_vec,
        collapse = ""
      )
    )
  }
  
  # interchange.middle.of.word = function(string,exclude=c(",",".","!","?")){
  # #  Regular Expression for gsub
  # ExcludeRegEx = paste(c("[",exclude,"]","$"),collapse = "")
  # # Remove excluded chars
  # CharOnly = gsub(ExcludeRegEx,"",string)
  # #Generate Vector
  # CharOnly.Vec = unlist(strsplit(CharOnly,split = ""))
  # 
  # if (nchar(CharOnly) < 4)
  # return(string)
  # else 
  #   paste(
  #     c(
  #       CharOnly.Vec[1],
  #       interchange.word(
  #         substr(
  #           CharOnly,2,
  #           length(CharOnly.Vec)-1
  #         )
  #       ),
  #       substring(string,length(CharOnly.Vec))),
  #   collapse = "")
  # 
  # }
}
```

Testing the function:

```{r}
interchange.middle.of.word("Tes")
```

```{r}
interchange.middle.of.word("Tes")
```

```{r}
interchange.middle.of.word("Hm?")
```

```{r}
interchange.middle.of.word("Hm!")
```

```{r}
interchange.middle.of.word("well!")
```

```{r}
interchange.middle.of.word("well!")
```

```{r}
interchange.middle.of.word("well!")
```

```{r}
interchange.middle.of.word("hello?")
```

```{r}
interchange.middle.of.word("Testfunction!")
```

```{r}
interchange.middle.of.word("Testfunction?")
```

```{r}
interchange.middle.of.word("Testfunction,")
```